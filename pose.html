<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pose Detection</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }
      #container {
        position: relative;
        width: 100%;
        height: 100%;
      }
      video,
      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }
    </style>
  </head>
  <body>
    <div id="container">
      <video id="webcam" autoplay playsinline></video>
      <canvas id="canvas"></canvas>
    </div>

    <script type="module">
      import {
        PoseLandmarker,
        FilesetResolver,
        DrawingUtils,
      } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0";

      let poseLandmarker;
      const video = document.getElementById("webcam");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      // One Euro Filter for smoothing
      class OneEuroFilter {
        constructor(minCutoff = 1.0, beta = 0.007) {
          this.minCutoff = minCutoff;
          this.beta = beta;
          this.xPrev = null;
          this.dxPrev = 0;
          this.tPrev = null;
        }

        filter(x, t) {
          if (this.tPrev === null) {
            this.tPrev = t;
            this.xPrev = x;
            return x;
          }

          const dt = t - this.tPrev;
          const dx = (x - this.xPrev) / dt;
          const edx = this.exponentialSmoothing(
            dx,
            this.dxPrev,
            this.alpha(dt, 1.0)
          );
          const cutoff = this.minCutoff + this.beta * Math.abs(edx);
          const filtered = this.exponentialSmoothing(
            x,
            this.xPrev,
            this.alpha(dt, cutoff)
          );

          this.xPrev = filtered;
          this.dxPrev = edx;
          this.tPrev = t;

          return filtered;
        }

        alpha(dt, cutoff) {
          const tau = 1.0 / (2 * Math.PI * cutoff);
          return 1.0 / (1.0 + tau / dt);
        }

        exponentialSmoothing(x, xPrev, alpha) {
          return alpha * x + (1 - alpha) * xPrev;
        }
      }

      // Filters for each landmark (33 landmarks Ã— 3 coordinates)
      const filters = Array.from({ length: 33 }, () => ({
        x: new OneEuroFilter(1.0, 0.007),
        y: new OneEuroFilter(1.0, 0.007),
        z: new OneEuroFilter(1.0, 0.007),
      }));

      // Initialize PoseLandmarker
      async function init() {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );
        poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task",
            delegate: "GPU",
          },
          runningMode: "VIDEO",
          numPoses: 2,
        });

        // Start webcam
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            frameRate: { ideal: 30 },
          },
        });
        video.srcObject = stream;
        video.addEventListener("loadeddata", predict);
      }

      // Resize canvas to match video
      function resizeCanvas() {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
      }

      let lastVideoTime = -1;
      async function predict() {
        if (canvas.width !== video.videoWidth) resizeCanvas();

        if (lastVideoTime !== video.currentTime) {
          lastVideoTime = video.currentTime;
          const result = await poseLandmarker.detectForVideo(
            video,
            performance.now()
          );

          ctx.save();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const drawingUtils = new DrawingUtils(ctx);

          for (const landmark of result.landmarks) {
            // Apply smoothing filter
            const smoothedLandmark = landmark.map((point, index) => ({
              x: filters[index].x.filter(point.x, performance.now()),
              y: filters[index].y.filter(point.y, performance.now()),
              z: filters[index].z.filter(point.z, performance.now()),
              visibility: point.visibility,
            }));

            drawingUtils.drawLandmarks(smoothedLandmark, {
              radius: (data) =>
                DrawingUtils.lerp(data.from.z, -0.15, 0.1, 5, 1),
            });
            drawingUtils.drawConnectors(
              smoothedLandmark,
              PoseLandmarker.POSE_CONNECTIONS
            );
          }
          ctx.restore();
        }

        requestAnimationFrame(predict);
      }

      init();
    </script>
  </body>
</html>
